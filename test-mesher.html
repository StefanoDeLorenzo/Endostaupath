<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <title>Test Mesher (chunk-based, sub-chunk 15³)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, Segoe UI, Roboto, sans-serif; margin: 16px; color: #222; }
    header { margin-bottom: 12px; }
    fieldset { border: 1px solid #ddd; padding: 12px; border-radius: 8px; margin-bottom: 12px; }
    legend { padding: 0 6px; color: #444; }
    label { display: inline-block; min-width: 140px; margin-right: 8px; }
    input[type="number"] { width: 100px; }
    button { padding: 6px 10px; border-radius: 6px; border: 1px solid #bbb; background: #f7f7f7; cursor: pointer; }
    button:disabled { opacity: .5; cursor: default; }
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    .grid { display: grid; grid-template-columns: repeat(auto-fit,minmax(260px,1fr)); gap: 12px; }
    .card { border: 1px solid #eee; border-radius: 8px; padding: 10px; }
    pre { background: #fafafa; border: 1px dashed #eee; padding: 8px; overflow: auto; max-height: 260px; }
    .muted { color: #666; }
    .ok { color: #0a7; }
    .warn { color: #a60; }
    .err { color: #b00; }
    code { background: #f2f2f2; padding: 2px 4px; border-radius: 4px; }
    .badge { display: inline-block; padding: 2px 6px; border-radius: 999px; background: #eef; }
    .small { font-size: 12px; }
  </style>
  <script src="voxel_types.js"></script>
</head>
<body>
  <header>
    <h1>Test Mesher</h1>
    <div class="muted">Meshing chunk 30×30×30 in sub-chunk 15³, renderer-agnostico (niente Babylon qui).</div>
  </header>

  <fieldset>
    <legend>1) Carica file .voxl (v5)</legend>
    <div class="row">
      <input id="fileInput" type="file" accept=".voxl,application/octet-stream" />
      <button id="btnInspect" disabled>Ispeziona header</button>
      <span id="fileInfo" class="muted"></span>
    </div>
    <pre id="inspectOut" hidden></pre>
  </fieldset>

  <fieldset>
    <legend>2) Seleziona Chunk & Inizializza Mesher</legend>
    <div class="row">
      <label for="chunkIndex">chunkIndex (0-63)</label>
      <input id="chunkIndex" type="number" min="0" max="63" value="0" />
      <label for="subSize">subchunkSize</label>
      <input id="subSize" type="number" min="5" max="30" step="1" value="15" />
      <button id="btnInit" disabled>Init mesher</button>
      <button id="btnBuildAll" disabled>Build ALL sub-chunk</button>
    </div>
    <div id="initInfo" class="muted"></div>
  </fieldset>

  <fieldset>
    <legend>3) Edit puntuali (applyEdits)</legend>
    <div class="row">
      <label for="editX">x</label><input id="editX" type="number" min="0" max="29" value="12" />
      <label for="editY">y</label><input id="editY" type="number" min="0" max="29" value="7" />
      <label for="editZ">z</label><input id="editZ" type="number" min="0" max="29" value="14" />
      <label for="editVal">newVal (locale 0..255)</label><input id="editVal" type="number" min="0" max="255" value="0" />
      <button id="btnApply" disabled>Applica edit</button>
      <span class="small muted">Tip: per rimuovere usa il valore “locale Air” del chunk (vedi sotto).</span>
    </div>
    <div id="paletteHint" class="small"></div>
  </fieldset>

  <div class="grid">
    <div class="card">
      <h3>Log</h3>
      <pre id="log"></pre>
    </div>
    <div class="card">
      <h3>Ultime submesh</h3>
      <pre id="lastSubmesh"></pre>
    </div>
  </div>

<script>
(() => {
  const logEl = document.getElementById('log');
  const lastSubmeshEl = document.getElementById('lastSubmesh');
  const inspectOut = document.getElementById('inspectOut');
  const fileInfo = document.getElementById('fileInfo');
  const initInfo = document.getElementById('initInfo');
  const btnInspect = document.getElementById('btnInspect');
  const btnInit = document.getElementById('btnInit');
  const btnBuildAll = document.getElementById('btnBuildAll');
  const btnApply = document.getElementById('btnApply');
  const fileInput = document.getElementById('fileInput');
  const chunkIndexInput = document.getElementById('chunkIndex');
  const subSizeInput = document.getElementById('subSize');
  const editX = document.getElementById('editX');
  const editY = document.getElementById('editY');
  const editZ = document.getElementById('editZ');
  const editVal = document.getElementById('editVal');
  const paletteHint = document.getElementById('paletteHint');

  const FILE_HEADER_SIZE = 11;
  const INDEX_ENTRY_SIZE = 5;
  const N = 30;
  const MASK_BYTES = 675;
  const BYTES_30CUBE = 27000;

  let regionBuffer = null;      // ArrayBuffer del file caricato
  let regionU8 = null;          // Uint8Array view
  let worker = null;
  let currentChunkType = 0;
  let currentChunkId = 'testChunk';
  let currentPaletteLocalAir = 0; // helper per rimozione

  const L = window.VoxelLib;
  const { ChunkType, VoxelSet, makePaletteForChunkType, getTypeId } = L;

  function log(msg) {
    logEl.textContent += msg + '\n';
    logEl.scrollTop = logEl.scrollHeight;
  }

  function be24(u8,i){ return (u8[i]<<16)|(u8[i+1]<<8)|u8[i+2]; }
  function be16(u8,i){ return (u8[i]<<8)|u8[i+1]; }

  // Leggi header file .voxl
  function inspectRegion(u8){
    const magic = (u8[0]<<24)|(u8[1]<<16)|(u8[2]<<8)|u8[3];
    if (magic !== 0x564F584C) throw new Error('Magic non VOXL');
    const version = u8[4];
    const dimX = u8[5], dimY = u8[6], dimZ = u8[7];
    const chunkCount = be24(u8, 8);
    return { version, dimX, dimY, dimZ, chunkCount };
  }

  function readChunk(u8, chunkIndex){
    const { dimX, dimY, dimZ, chunkCount } = inspectRegion(u8);
    if (chunkIndex<0 || chunkIndex>=chunkCount) throw new Error('chunkIndex fuori range');
    const indexStart = FILE_HEADER_SIZE;
    const base = indexStart + chunkIndex*INDEX_ENTRY_SIZE;
    const off = be24(u8, base+0);
    const size = be16(u8, base+3);

    const hdrLen = u8[off+0];
    const hdrVer = u8[off+1];
    const chunkType = u8[off+2];
    const mediumType = u8[off+3];

    const voxStart = off + hdrLen;
    const voxEnd = voxStart + (dimX*dimY*dimZ);
    const voxels = new Uint8Array(u8.buffer, u8.byteOffset+voxStart, dimX*dimY*dimZ);

    const maskStart = voxEnd;
    const borderMask = new Uint8Array(u8.buffer, u8.byteOffset+maskStart, MASK_BYTES);

    return { dimX, dimY, dimZ, chunkType, mediumType, voxels, borderMask, size, hdrLen, off };
  }

  fileInput.addEventListener('change', async (e) => {
    const f = e.target.files?.[0];
    if (!f) return;
    regionBuffer = await f.arrayBuffer();
    regionU8 = new Uint8Array(regionBuffer);
    btnInspect.disabled = false;
    fileInfo.textContent = `${f.name} (${(f.size/1024).toFixed(1)} KB)`;
    inspectOut.hidden = true;
    initInfo.textContent = '';
    logEl.textContent = '';
    lastSubmeshEl.textContent = '';
    btnInit.disabled = false;
    btnBuildAll.disabled = true;
    btnApply.disabled = true;
  });

  btnInspect.addEventListener('click', () => {
    if (!regionU8) return;
    try {
      const h = inspectRegion(regionU8);
      inspectOut.textContent = JSON.stringify(h, null, 2);
      inspectOut.hidden = false;
      log('Header OK: ' + JSON.stringify(h));
    } catch (err) {
      inspectOut.hidden = false;
      inspectOut.textContent = 'Errore: ' + err.message;
    }
  });

  function ensureWorker(){
    if (worker) return worker;
    worker = new Worker('mesher_worker.js');
    worker.onmessage = (e) => {
      const m = e.data || {};
      if (m.type === 'chunkReady') {
        log(`✅ chunkReady: ${m.chunkId}`);
        btnBuildAll.disabled = false;
        btnApply.disabled = false;
      } else if (m.type === 'submeshReady') {
        const totOpaque = Object.values(m.batches.opaque).reduce((a,b)=>a + (b.indices.length/3), 0);
        const totTrans  = Object.values(m.batches.translucent).reduce((a,b)=>a + (b.indices.length/3), 0);
        lastSubmeshEl.textContent =
          `subIndex: [${m.subIndex.join(', ')}]\n` +
          `faces opaque: ${totOpaque}\nfaces translucent: ${totTrans}\n` +
          `stats: ${JSON.stringify(m.stats)}`;
      } else if (m.type === 'meshError') {
        log(`❌ meshError: ${m.error}`);
      }
    };
    return worker;
  }

  // Calcola il valore locale "Air" per suggerire rimozioni corrette
  function computeLocalAirFor(chunkType){
    const pal = makePaletteForChunkType(chunkType);
    let localAir = 0;
    for (let i=0;i<256;i++){
      const bs = pal[i];
      const typeId = getTypeId(bs);
      if (typeId === L.VoxelSet.T.Air) { localAir = i; break; }
    }
    return localAir;
  }

  btnInit.addEventListener('click', () => {
    if (!regionU8) return;
    const idx = parseInt(chunkIndexInput.value, 10) || 0;
    const subSize = Math.max(5, Math.min(30, parseInt(subSizeInput.value, 10) || 15));
    try {
      const rec = readChunk(regionU8, idx);
      currentChunkType = rec.chunkType;
      currentPaletteLocalAir = computeLocalAirFor(currentChunkType);

      initInfo.innerHTML =
        `Chunk <span class="badge">${idx}</span> — ` +
        `chunkType: <code>${rec.chunkType}</code>, medium: <code>${rec.mediumType}</code>, ` +
        `voxels: <code>${rec.voxels.byteLength}</code>, mask: <code>${rec.borderMask.byteLength}</code>, ` +
        `subSize: <code>${subSize}</code>`;

      paletteHint.innerHTML =
        `Valore locale “Air” consigliato per rimozione: <code>${currentPaletteLocalAir}</code>` +
        ` (chunkType=${rec.chunkType}).`;

      const w = ensureWorker();
      // Copie sicure da passare (oppure trasferisci direttamente se non ti servono più qui)
      const voxCopy = new Uint8Array(rec.voxels);     // 27k
      const maskCopy = new Uint8Array(rec.borderMask);// 675

      w.postMessage({
        type: 'initChunk',
        chunkId: currentChunkId,
        chunkType: rec.chunkType,
        voxels: voxCopy,
        borderMask: maskCopy,
        options: { subchunkSize: subSize }
      });
      log(`→ initChunk inviato (chunkIndex=${idx})`);
    } catch (err) {
      log('Errore init: ' + err.message);
    }
  });

  btnBuildAll.addEventListener('click', () => {
    if (!worker) return;
    worker.postMessage({ type:'buildAll', chunkId: currentChunkId });
    log('→ buildAll inviato');
  });

  btnApply.addEventListener('click', () => {
    if (!worker) return;
    const x = parseInt(editX.value, 10)|0;
    const y = parseInt(editY.value, 10)|0;
    const z = parseInt(editZ.value, 10)|0;
    let v = parseInt(editVal.value, 10)|0;
    v = Math.max(0, Math.min(255, v));
    worker.postMessage({
      type:'applyEdits',
      chunkId: currentChunkId,
      edits: [{ x, y, z, newVal: v }]
    });
    log(`→ applyEdits: (${x},${y},${z}) = ${v}`);
  });

})();
</script>
</body>
</html>
