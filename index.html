<!DOCTYPE html>
<html>
<head>
    <title>Voxel World</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Impostazioni del mondo
        const CHUNK_SIZE_LOGIC = 30;
        const REGION_CHUNKS = 4;
        const REGION_HEIGHT = 4;
        
        // Setup di base di Three.js
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        camera.position.z = 5;

        // Gestione delle luci
        const ambientLight = new THREE.AmbientLight(0x404040, 2);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        // Gestione dei worker
        const worker = new Worker('worker.js');
        const chunks = new Map();
        const loadingRegions = new Map();
        const regions = new Map();

        let playerChunkX = 0;
        let playerChunkY = 0;
        let playerChunkZ = 0;
        const renderDistance = 2;
        
        function loadChunk(chunkX, chunkY, chunkZ) {
            const chunkKey = `${chunkX},${chunkY},${chunkZ}`;
            if (chunks.has(chunkKey)) return;

            const regionX = Math.floor(chunkX / REGION_CHUNKS);
            const regionY = Math.floor(chunkY / REGION_HEIGHT);
            const regionZ = Math.floor(chunkZ / REGION_CHUNKS);

            // CORREZIONE: Aggiunto il percorso relativo "./regions/"
            const regionKey = `./regions/r.${regionX}.${regionY}.${regionZ}.voxl`;

            if (!regions.has(regionKey)) {
                if (!loadingRegions.has(regionKey)) {
                    loadingRegions.set(regionKey, true);
                    fetch(regionKey)
                        .then(response => {
                            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                            return response.arrayBuffer();
                        })
                        .then(buffer => {
                            regions.set(regionKey, buffer);
                            loadingRegions.delete(regionKey);
                            loadChunk(chunkX, chunkY, chunkZ);
                        })
                        .catch(e => {
                            console.error(`Errore nel caricamento della regione ${regionKey}:`, e);
                            loadingRegions.delete(regionKey);
                        });
                }
                return;
            }

            const chunkLocalX = chunkX % REGION_CHUNKS;
            const chunkLocalY = chunkY % REGION_HEIGHT;
            const chunkLocalZ = chunkZ % REGION_CHUNKS;
            
            worker.postMessage({
                type: 'loadChunkFromRegion',
                regionBuffers: { [regionKey]: regions.get(regionKey) },
                chunkX, chunkY, chunkZ,
                chunkLocalX, chunkLocalY, chunkLocalZ
            });
            chunks.set(chunkKey, 'loading');
        }

        worker.onmessage = (event) => {
            if (event.data.type === 'chunkGenerated') {
                const { chunkX, chunkY, chunkZ, meshData } = event.data;
                const chunkKey = `${chunkX},${chunkY},${chunkZ}`;

                if (meshData.positions.length > 0) {
                    const geometry = new THREE.BufferGeometry();
                    geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(meshData.positions), 3));
                    geometry.setAttribute('normal', new THREE.BufferAttribute(new Float32Array(meshData.normals), 3));
                    geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(meshData.colors), 4));
                    geometry.setIndex(new THREE.BufferAttribute(new Uint16Array(meshData.indices), 1));
                    
                    const material = new THREE.MeshLambertMaterial({
                        vertexColors: true
                    });
                    
                    const mesh = new THREE.Mesh(geometry, material);
                    
                    mesh.position.set(
                        chunkX * CHUNK_SIZE_LOGIC,
                        chunkY * CHUNK_SIZE_LOGIC,
                        chunkZ * CHUNK_SIZE_LOGIC
                    );

                    scene.add(mesh);
                    chunks.set(chunkKey, mesh);
                } else {
                    chunks.set(chunkKey, 'empty');
                }
            }
        };

        function updateChunks() {
            // Per il momento carichiamo solo un chunk per test
            loadChunk(0, 0, 0); 
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
            updateChunks();
        }

        animate();
    </script>
</body>
</html>