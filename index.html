<!DOCTYPE html>
<html>
<head>
    <title>Voxel World</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Impostazioni del mondo
        const CHUNK_SIZE_LOGIC = 30; // La nostra unitÃ  di base
        const REGION_CHUNKS = 4;
        const REGION_HEIGHT = 4;
        
        // Setup di base di Three.js
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        camera.position.z = 5;

        // Gestione delle luci
        const ambientLight = new THREE.AmbientLight(0x404040, 2);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        // Gestione dei worker
        const worker = new Worker('worker.js');
        const regionWorker = new Worker('regionWorker.js'); // Usiamo un worker dedicato per caricare le regioni
        const chunks = new Map();
        const loadingRegions = new Map();
        const regions = new Map();

        // Variabili del giocatore per il caricamento dinamico
        let playerChunkX = 0;
        let playerChunkY = 0;
        let playerChunkZ = 0;
        const renderDistance = 2; // Raggio di chunk da caricare
        
        // Funzione per inviare i dati al worker
        function loadChunk(chunkX, chunkY, chunkZ) {
            const chunkKey = `${chunkX},${chunkY},${chunkZ}`;
            if (chunks.has(chunkKey)) return;

            const regionX = Math.floor(chunkX / REGION_CHUNKS);
            const regionY = Math.floor(chunkY / REGION_HEIGHT);
            const regionZ = Math.floor(chunkZ / REGION_CHUNKS);
            const regionKey = `r.${regionX}.${regionY}.${regionZ}.voxl`;

            if (!regions.has(regionKey)) {
                if (!loadingRegions.has(regionKey)) {
                    loadingRegions.set(regionKey, true);
                    // Richiesta di caricamento asincrono della regione
                    fetch(regionKey)
                        .then(response => {
                            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                            return response.arrayBuffer();
                        })
                        .then(buffer => {
                            regions.set(regionKey, buffer);
                            loadingRegions.delete(regionKey);
                            loadChunk(chunkX, chunkY, chunkZ);
                        })
                        .catch(e => {
                            console.error(`Errore nel caricamento della regione ${regionKey}:`, e);
                            loadingRegions.delete(regionKey);
                        });
                }
                return;
            }

            const chunkLocalX = chunkX % REGION_CHUNKS;
            const chunkLocalY = chunkY % REGION_HEIGHT;
            const chunkLocalZ = chunkZ % REGION_CHUNKS;
            
            // Invia al worker le informazioni necessarie per generare la mesh
            worker.postMessage({
                type: 'loadChunkFromRegion',
                regionBuffers: { [regionKey]: regions.get(regionKey) },
                chunkX, chunkY, chunkZ,
                chunkLocalX, chunkLocalY, chunkLocalZ
            });
            chunks.set(chunkKey, 'loading');
        }

        // Listener per i messaggi dal worker
        worker.onmessage = (event) => {
            if (event.data.type === 'chunkGenerated') {
                const { chunkX, chunkY, chunkZ, meshData } = event.data;
                const chunkKey = `${chunkX},${chunkY},${chunkZ}`;

                if (meshData.positions.length > 0) {
                    const geometry = new THREE.BufferGeometry();
                    geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(meshData.positions), 3));
                    geometry.setAttribute('normal', new THREE.BufferAttribute(new Float32Array(meshData.normals), 3));
                    geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(meshData.colors), 4));
                    geometry.setIndex(new THREE.BufferAttribute(new Uint16Array(meshData.indices), 1));
                    
                    const material = new THREE.MeshLambertMaterial({
                        vertexColors: true
                    });
                    
                    const mesh = new THREE.Mesh(geometry, material);
                    
                    // POSIZIONAMENTO CORRETTO:
                    // I chunk logici di 30x30x30 sono adiacenti.
                    // Moltiplichiamo le coordinate del chunk per la sua dimensione logica (30)
                    mesh.position.set(
                        chunkX * CHUNK_SIZE_LOGIC,
                        chunkY * CHUNK_SIZE_LOGIC,
                        chunkZ * CHUNK_SIZE_LOGIC
                    );

                    scene.add(mesh);
                    chunks.set(chunkKey, mesh);
                } else {
                    chunks.set(chunkKey, 'empty');
                }
            }
        };

        // Aggiorna i chunk in base alla posizione del giocatore
        function updateChunks() {
            const currentChunkX = Math.floor(camera.position.x / CHUNK_SIZE_LOGIC);
            const currentChunkY = Math.floor(camera.position.y / CHUNK_SIZE_LOGIC);
            const currentChunkZ = Math.floor(camera.position.z / CHUNK_SIZE_LOGIC);

            if (currentChunkX !== playerChunkX || currentChunkY !== playerChunkY || currentChunkZ !== playerChunkZ) {
                // Svuota la scena e ricarica i chunk in un'applicazione reale
                // Per ora, ci limitiamo a caricare i nuovi chunk
                playerChunkX = currentChunkX;
                playerChunkY = currentChunkY;
                playerChunkZ = currentChunkZ;

                for (let x = -renderDistance; x <= renderDistance; x++) {
                    for (let y = -renderDistance; y <= renderDistance; y++) {
                        for (let z = -renderDistance; z <= renderDistance; z++) {
                            const chunkX = playerChunkX + x;
                            const chunkY = playerChunkY + y;
                            const chunkZ = playerChunkZ + z;
                            loadChunk(chunkX, chunkY, chunkZ);
                        }
                    }
                }
            }
        }

        // Animazione del rendering
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
            updateChunks();
        }

        animate();
    </script>
</body>
</html>