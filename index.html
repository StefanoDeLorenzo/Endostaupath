<!DOCTYPE html>
<html>
<head>
    <title>Voxel World</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Impostazioni del mondo
        const CHUNK_SIZE_LOGIC = 30;
        const REGION_CHUNKS = 4;
        const REGION_HEIGHT = 4;
        
        // Setup di base di Three.js
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Posiziona la telecamera inizialmente a una distanza ragionevole
        camera.position.set(CHUNK_SIZE_LOGIC * 0.5, CHUNK_SIZE_LOGIC * 2, CHUNK_SIZE_LOGIC * 2);

        // Gestione delle luci
        const ambientLight = new THREE.AmbientLight(0x404040, 2);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        // Gestione dei worker
        const worker = new Worker('worker.js');
        const chunks = new Map();
        const loadingRegions = new Map();
        const regions = new Map();

        // Variabili del giocatore per il caricamento dinamico
        let playerChunkX = 0;
        let playerChunkY = 0;
        let playerChunkZ = 0;
        const renderDistance = 2;
        
        function loadChunk(chunkX, chunkY, chunkZ) {
            const chunkKey = `${chunkX},${chunkY},${chunkZ}`;
            if (chunks.has(chunkKey)) return;

            const regionX = Math.floor(chunkX / REGION_CHUNKS);
            const regionY = Math.floor(chunkY / REGION_HEIGHT);
            const regionZ = Math.floor(chunkZ / REGION_CHUNKS);

            const regionKey = `./regions/r.${regionX}.${regionY}.${regionZ}.voxl`;

            if (!regions.has(regionKey)) {
                if (!loadingRegions.has(regionKey)) {
                    loadingRegions.set(regionKey, true);
                    fetch(regionKey)
                        .then(response => {
                            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                            return response.arrayBuffer();
                        })
                        .then(buffer => {
                            regions.set(regionKey, buffer);
                            loadingRegions.delete(regionKey);
                            loadChunk(chunkX, chunkY, chunkZ);
                        })
                        .catch(e => {
                            console.error(`Errore nel caricamento della regione ${regionKey}:`, e);
                            loadingRegions.delete(regionKey);
                        });
                }
                return;
            }

            const chunkLocalX = ((chunkX % REGION_CHUNKS) + REGION_CHUNKS) % REGION_CHUNKS;
            const chunkLocalY = ((chunkY % REGION_HEIGHT) + REGION_HEIGHT) % REGION_HEIGHT;
            const chunkLocalZ = ((chunkZ % REGION_CHUNKS) + REGION_CHUNKS) % REGION_CHUNKS;
            
            worker.postMessage({
                type: 'loadChunkFromRegion',
                regionBuffers: { [regionKey]: regions.get(regionKey) },
                chunkX, chunkY, chunkZ,
                chunkLocalX, chunkLocalY, chunkLocalZ
            });
            chunks.set(chunkKey, 'loading');
        }

        worker.onmessage = (event) => {
            if (event.data.type === 'chunkGenerated') {
                const { chunkX, chunkY, chunkZ, meshData } = event.data;
                const chunkKey = `${chunkX},${chunkY},${chunkZ}`;

                if (meshData.positions.length > 0) {
                    const geometry = new THREE.BufferGeometry();
                    geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(meshData.positions), 3));
                    geometry.setAttribute('normal', new THREE.BufferAttribute(new Float32Array(meshData.normals), 3));
                    geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(meshData.colors), 4));
                    geometry.setIndex(new THREE.BufferAttribute(new Uint16Array(meshData.indices), 1));
                    
                    const material = new THREE.MeshLambertMaterial({
                        vertexColors: true
                    });
                    
                    const mesh = new THREE.Mesh(geometry, material);
                    
                    mesh.position.set(
                        chunkX * CHUNK_SIZE_LOGIC,
                        chunkY * CHUNK_SIZE_LOGIC,
                        chunkZ * CHUNK_SIZE_LOGIC
                    );

                    scene.add(mesh);
                    chunks.set(chunkKey, mesh);
                } else {
                    chunks.set(chunkKey, 'empty');
                }
            }
        };

        function updateChunks() {
            const currentChunkX = Math.floor(camera.position.x / CHUNK_SIZE_LOGIC);
            const currentChunkY = Math.floor(camera.position.y / CHUNK_SIZE_LOGIC);
            const currentChunkZ = Math.floor(camera.position.z / CHUNK_SIZE_LOGIC);

            if (currentChunkX !== playerChunkX || currentChunkY !== playerChunkY || currentChunkZ !== playerChunkZ) {
                playerChunkX = currentChunkX;
                playerChunkY = currentChunkY;
                playerChunkZ = currentChunkZ;
                console.log(`Caricamento nuovi chunk attorno a: ${playerChunkX}, ${playerChunkY}, ${playerChunkZ}`);

                for (let x = -renderDistance; x <= renderDistance; x++) {
                    for (let y = -renderDistance; y <= renderDistance; y++) {
                        for (let z = -renderDistance; z <= renderDistance; z++) {
                            const chunkX = playerChunkX + x;
                            const chunkY = playerChunkY + y;
                            const chunkZ = playerChunkZ + z;
                            loadChunk(chunkX, chunkY, chunkZ);
                        }
                    }
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
            updateChunks();
        }

        animate();
    </script>
</body>
</html>