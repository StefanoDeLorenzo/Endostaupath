<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Voxel Engine con Babylon.js</title>
    <style>
        body, html, canvas {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    
    <script>
        const CHUNK_SIZE = 30;
        const CHUNK_SIZE_SHELL = 32;
        const REGION_DIMENSION = 4;

        class SceneManager {
            constructor(scene, engine, canvas) {
                this.scene = scene;
                this.engine = engine;
                this.canvas = canvas;
                this.workers = new Map();
                this.sceneMaterials = {};
                this.initializeScene();
            }

            initializeScene() {
                this.scene.ambientColor = new BABYLON.Color3(0.4, 0.4, 0.4);
                this.createCamera();
                this.createLight();
            }

            createCamera() {
                const camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(60, 60, 60), this.scene);
                camera.setTarget(new BABYLON.Vector3(60, 0, 60)); 
                camera.attachControl(this.canvas, true);
                camera.keysUp.push(87);    // W
                camera.keysDown.push(83);  // S
                camera.keysLeft.push(65);  // A
                camera.keysRight.push(68); // D
            }
            
            createLight() {
                const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), this.scene);
                light.intensity = 0.7;
            }

            getOrCreateMaterial(voxelType, isTransparent, materialAlpha = 1.0) {
                if (!this.sceneMaterials[voxelType]) {
                    const material = new BABYLON.StandardMaterial(`material_${voxelType}`, this.scene);
                    material.useVertexColors = true;
                    if (isTransparent) {
                        material.alpha = materialAlpha;
                        material.hasAlpha = true;
                        material.alphaMode = BABYLON.Engine.ALPHA_COMBINE;
                        material.backFaceCulling = false;
                    }
                    this.sceneMaterials[voxelType] = material;
                }
                return this.sceneMaterials[voxelType];
            }

            getChunkDataFromRegionBuffer(buffer, chunkX, chunkY, chunkZ) {
                const dataView = new DataView(buffer);
                const headerSize = 11;
                const chunkIndex = chunkZ + REGION_DIMENSION * (chunkY + REGION_DIMENSION * chunkX);
                const offsetIndex = headerSize + chunkIndex * 5;
                const chunkFileOffset = (dataView.getUint8(offsetIndex) << 16) | (dataView.getUint8(offsetIndex + 1) << 8) | dataView.getUint8(offsetIndex + 2);

                if (chunkFileOffset === 0) {
                    return null;
                }
                const chunkSizeInBytes = CHUNK_SIZE_SHELL * CHUNK_SIZE_SHELL * CHUNK_SIZE_SHELL;
                const chunkBuffer = buffer.slice(chunkFileOffset, chunkFileOffset + chunkSizeInBytes);
                return new Uint8Array(chunkBuffer);
            }

            async loadRegionAndMeshAllChunks(regionX, regionY, regionZ) {
                try {
                    const regionPath = `./regions/r.${regionX}.${regionY}.${regionZ}.voxl`;
                    console.log(`Thread principale: Caricamento del file ${regionPath}...`);
                    const response = await fetch(regionPath);
                    if (!response.ok) {
                        console.error(`Regione (${regionX}, ${regionY}, ${regionZ}) non trovata. Trattata come vuota.`);
                        return;
                    }

                    const buffer = await response.arrayBuffer();
                    console.log(`Thread principale: File caricato. Dimensione: ${buffer.byteLength} byte.`);
                    
                    for (let chunkX = 0; chunkX < REGION_DIMENSION; chunkX++) {
                        for (let chunkY = 0; chunkY < REGION_DIMENSION; chunkY++) {
                            for (let chunkZ = 0; chunkZ < REGION_DIMENSION; chunkZ++) {
                                const chunkData = this.getChunkDataFromRegionBuffer(buffer, chunkX, chunkY, chunkZ);
                                if (chunkData === null) {
                                    continue;
                                }
                                const workerId = `chunk_${regionX}_${regionY}_${regionZ}_${chunkX}_${chunkY}_${chunkZ}`;
                                const worker = new Worker('worker.js');
                                this.workers.set(workerId, worker);
                                
                                worker.onmessage = (event) => {
                                    const { type, meshDataByVoxelType, voxelOpacity } = event.data;
                                    if (type === 'meshGenerated' && meshDataByVoxelType) {
                                        const worldX = (regionX * REGION_DIMENSION + chunkX) * CHUNK_SIZE;
                                        const worldY = (regionY * REGION_DIMENSION + chunkY) * CHUNK_SIZE;
                                        const worldZ = (regionZ * REGION_DIMENSION + chunkZ) * CHUNK_SIZE;
                                        for (const voxelType in meshDataByVoxelType) {
                                            const meshData = meshDataByVoxelType[voxelType];
                                            if (meshData.positions.length > 0) {
                                                const isTransparent = (voxelOpacity[voxelType] === 'transparent');
                                                const meshName = `chunk_${regionX}_${regionY}_${regionZ}_${voxelType}`;
                                                const mesh = new BABYLON.Mesh(meshName, this.scene);
                                                const vertexData = new BABYLON.VertexData();
                                                Object.assign(vertexData, meshData);
                                                vertexData.applyToMesh(mesh);
                                                const materialAlpha = isTransparent ? meshData.colors[3] : 1.0;
                                                mesh.material = this.getOrCreateMaterial(voxelType, isTransparent, materialAlpha);
                                                mesh.position = new BABYLON.Vector3(worldX, worldY, worldZ);
                                            }
                                        }
                                        worker.terminate();
                                        this.workers.delete(workerId);
                                    }
                                };
                                
                                worker.postMessage({
                                    type: 'generateMeshFromChunk',
                                    chunkData: chunkData.buffer,
                                    chunkX, chunkY, chunkZ
                                }, [chunkData.buffer]);
                            }
                        }
                    }
                } catch (error) {
                    console.error(`Errore durante il caricamento del file della regione (${regionX}, ${regionY}, ${regionZ}):`, error);
                }
            }

            // Nuovo metodo corretto per stampare la posizione della camera e dei chunk adiacenti
            printChunkAndRegionInfo(playerPosition) {
                const currentRegionX = Math.floor(playerPosition.x / (CHUNK_SIZE * REGION_DIMENSION));
                const currentRegionY = Math.floor(playerPosition.y / (CHUNK_SIZE * REGION_DIMENSION));
                const currentRegionZ = Math.floor(playerPosition.z / (CHUNK_SIZE * REGION_DIMENSION));

                const currentChunkX = Math.floor((playerPosition.x - currentRegionX * CHUNK_SIZE * REGION_DIMENSION) / CHUNK_SIZE);
                const currentChunkY = Math.floor((playerPosition.y - currentRegionY * CHUNK_SIZE * REGION_DIMENSION) / CHUNK_SIZE);
                const currentChunkZ = Math.floor((playerPosition.z - currentRegionZ * CHUNK_SIZE * REGION_DIMENSION) / CHUNK_SIZE);

                console.log("-----------------------------------------");
                console.log(`Posizione Camera: X: ${playerPosition.x}, Y: ${playerPosition.y}, Z: ${playerPosition.z}`);
                console.log(`Regione Attuale: (${currentRegionX}, ${currentRegionY}, ${currentRegionZ})`);
                console.log(`Chunk Attuale: (${currentChunkX}, ${currentChunkY}, ${currentChunkZ})`);
                console.log("-----------------------------------------");
                console.log("Chunk adiacenti (e le loro regioni):");
                
                for (let x = -1; x <= 1; x++) {
                    for (let y = -1; y <= 1; y++) {
                        for (let z = -1; z <= 1; z++) {
                            // Ignora il chunk centrale (quello della camera)
                            if (x === 0 && y === 0 && z === 0) {
                                continue;
                            }
                            
                            const worldChunkX = currentChunkX + x;
                            const worldChunkY = currentChunkY + y;
                            const worldChunkZ = currentChunkZ + z;
                            
                            // Calcola la regione e il chunk corretto per l'adiacente
                            const adjacentRegionX = currentRegionX + Math.floor(worldChunkX / REGION_DIMENSION);
                            const adjacentRegionY = currentRegionY + Math.floor(worldChunkY / REGION_DIMENSION);
                            const adjacentRegionZ = currentRegionZ + Math.floor(worldChunkZ / REGION_DIMENSION);

                            const adjacentChunkX = (worldChunkX % REGION_DIMENSION + REGION_DIMENSION) % REGION_DIMENSION;
                            const adjacentChunkY = (worldChunkY % REGION_DIMENSION + REGION_DIMENSION) % REGION_DIMENSION;
                            const adjacentChunkZ = (worldChunkZ % REGION_DIMENSION + REGION_DIMENSION) % REGION_DIMENSION;

                            console.log(`Chunk adiacente: (${adjacentChunkX}, ${adjacentChunkY}, ${adjacentChunkZ}) nella Regione (${adjacentRegionX}, ${adjacentRegionY}, ${adjacentRegionZ})`);
                        }
                    }
                }
            }
        }

        class Game {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.engine = new BABYLON.Engine(this.canvas, true);
                this.scene = new BABYLON.Scene(this.engine);
                this.sceneManager = new SceneManager(this.scene, this.engine, this.canvas);
                this.player = this.scene.activeCamera;
            }

            start() {
                this.sceneManager.loadRegionAndMeshAllChunks(0, 0, 0);
                this.sceneManager.loadRegionAndMeshAllChunks(1, 0, 0);

                

                this.engine.runRenderLoop(() => {
                    this.scene.render();
                    this.checkCameraPosition();
                });

                window.addEventListener("resize", () => {
                    this.engine.resize();
                    
                });
            }

            checkCameraPosition() {
                const playerPosition = this.player.position;
                const currentRegionX = Math.floor(playerPosition.x / (CHUNK_SIZE * REGION_DIMENSION));
                const currentRegionY = Math.floor(playerPosition.y / (CHUNK_SIZE * REGION_DIMENSION));
                const currentRegionZ = Math.floor(playerPosition.z / (CHUNK_SIZE * REGION_DIMENSION));

                const currentChunkX = Math.floor((playerPosition.x - currentRegionX * CHUNK_SIZE * REGION_DIMENSION) / CHUNK_SIZE);
                const currentChunkY = Math.floor((playerPosition.y - currentRegionY * CHUNK_SIZE * REGION_DIMENSION) / CHUNK_SIZE);
                const currentChunkZ = Math.floor((playerPosition.z - currentRegionZ * CHUNK_SIZE * REGION_DIMENSION) / CHUNK_SIZE);

                // Controllo se il chunk attuale è diverso dall'ultimo chunk registrato
                if (currentChunkX !== this.lastChunk.x || currentChunkY !== this.lastChunk.y || currentChunkZ !== this.lastChunk.z) {
                    this.sceneManager.printChunkAndRegionInfo(playerPosition);
                    this.lastChunk = { x: currentChunkX, y: currentChunkY, z: currentChunkZ };
                }
            }
        }
        
        const game = new Game("renderCanvas");
        game.start();
    </script>
</body>
</html>