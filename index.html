<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Voxel Engine con Babylon.js</title>
    <style>
        body, html, canvas {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    
    <script>
        const CHUNK_SIZE = 30;
        const CHUNK_SIZE_SHELL = 32;
        const REGION_DIMENSION = 4;

        class SceneManager {
            constructor(scene, engine, canvas) {
                this.scene = scene;
                this.engine = engine;
                this.canvas = canvas;
                this.workers = new Map();
                this.sceneMaterials = {};
                this.initializeScene();
            }

            initializeScene() {
                this.scene.ambientColor = new BABYLON.Color3(0.4, 0.4, 0.4);
                this.createCamera();
                this.createLight();
            }

            createCamera() {
                const camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(60, 60, -60), this.scene);
                camera.setTarget(new BABYLON.Vector3(60, 0, 60)); 
                camera.attachControl(this.canvas, true);
                camera.keysUp.push(87);    // W
                camera.keysDown.push(83);  // S
                camera.keysLeft.push(65);  // A
                camera.keysRight.push(68); // D
            }
            
            createLight() {
                const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), this.scene);
                light.intensity = 0.7;
            }

            getOrCreateMaterial(voxelType, isTransparent, materialAlpha = 1.0) {
                if (!this.sceneMaterials[voxelType]) {
                    const material = new BABYLON.StandardMaterial(`material_${voxelType}`, this.scene);
                    material.useVertexColors = true;
                    if (isTransparent) {
                        material.alpha = materialAlpha;
                        material.hasAlpha = true;
                        material.alphaMode = BABYLON.Engine.ALPHA_COMBINE;
                        material.backFaceCulling = false;
                    }
                    this.sceneMaterials[voxelType] = material;
                }
                return this.sceneMaterials[voxelType];
            }

            getChunkDataFromRegionBuffer(buffer, chunkX, chunkY, chunkZ) {
                const dataView = new DataView(buffer);
                const headerSize = 11;
                const chunkIndex = chunkZ + REGION_DIMENSION * (chunkY + REGION_DIMENSION * chunkX);
                const offsetIndex = headerSize + chunkIndex * 5;
                const chunkFileOffset = (dataView.getUint8(offsetIndex) << 16) | (dataView.getUint8(offsetIndex + 1) << 8) | dataView.getUint8(offsetIndex + 2);

                if (chunkFileOffset === 0) {
                    return null;
                }
                const chunkSizeInBytes = CHUNK_SIZE_SHELL * CHUNK_SIZE_SHELL * CHUNK_SIZE_SHELL;
                const chunkBuffer = buffer.slice(chunkFileOffset, chunkFileOffset + chunkSizeInBytes);
                return new Uint8Array(chunkBuffer);
            }

            async loadRegionAndMeshAllChunks(regionX, regionY, regionZ) {
                try {
                    const regionPath = `./regions/r.${regionX}.${regionY}.${regionZ}.voxl`;
                    console.log(`Thread principale: Caricamento del file ${regionPath}...`);
                    const response = await fetch(regionPath);
                    if (!response.ok) {
                        console.error(`Regione (${regionX}, ${regionY}, ${regionZ}) non trovata. Trattata come vuota.`);
                        return;
                    }

                    const buffer = await response.arrayBuffer();
                    console.log(`Thread principale: File caricato. Dimensione: ${buffer.byteLength} byte.`);
                    
                    for (let chunkX = 0; chunkX < REGION_DIMENSION; chunkX++) {
                        for (let chunkY = 0; chunkY < REGION_DIMENSION; chunkY++) {
                            for (let chunkZ = 0; chunkZ < REGION_DIMENSION; chunkZ++) {
                                const chunkData = this.getChunkDataFromRegionBuffer(buffer, chunkX, chunkY, chunkZ);
                                if (chunkData === null) {
                                    continue;
                                }
                                const workerId = `chunk_${regionX}_${regionY}_${regionZ}_${chunkX}_${chunkY}_${chunkZ}`;
                                const worker = new Worker('worker.js');
                                this.workers.set(workerId, worker);
                                worker.onmessage = (event) => {
                                    const { type, chunkX, chunkY, chunkZ, meshDataByVoxelType, voxelOpacity } = event.data;
                                    if (type === 'meshGenerated' && meshDataByVoxelType) {
                                        const worldX = (regionX * REGION_DIMENSION + chunkX) * CHUNK_SIZE;
                                        const worldY = (regionY * REGION_DIMENSION + chunkY) * CHUNK_SIZE;
                                        const worldZ = (regionZ * REGION_DIMENSION + chunkZ) * CHUNK_SIZE;
                                        for (const voxelType in meshDataByVoxelType) {
                                            const meshData = meshDataByVoxelType[voxelType];
                                            if (meshData.positions.length > 0) {
                                                const isTransparent = (voxelOpacity[voxelType] === 'transparent');
                                                const meshName = `chunk_${regionX}_${regionY}_${regionZ}_${voxelType}`;
                                                const mesh = new BABYLON.Mesh(meshName, this.scene);
                                                const vertexData = new BABYLON.VertexData();
                                                Object.assign(vertexData, meshData);
                                                vertexData.applyToMesh(mesh);
                                                const materialAlpha = isTransparent ? meshData.colors[3] : 1.0;
                                                mesh.material = this.getOrCreateMaterial(voxelType, isTransparent, materialAlpha);
                                                mesh.position = new BABYLON.Vector3(worldX, worldY, worldZ);
                                            }
                                        }
                                        worker.terminate();
                                        this.workers.delete(workerId);
                                    }
                                };
                                worker.postMessage({
                                    type: 'generateMeshFromChunk',
                                    chunkData: chunkData.buffer, 
                                    chunkX, chunkY, chunkZ
                                }, [chunkData.buffer]); 
                            }
                        }
                    }
                } catch (error) {
                    console.error(`Errore durante il caricamento del file della regione (${regionX}, ${regionY}, ${regionZ}):`, error);
                }
            }
        }

        class Game {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.engine = new BABYLON.Engine(this.canvas, true);
                this.scene = new BABYLON.Scene(this.engine);
                this.sceneManager = new SceneManager(this.scene, this.engine, this.canvas);
            }

            start() {
                // Carica esplicitamente due regioni adiacenti sull'asse X
                this.sceneManager.loadRegionAndMeshAllChunks(0, 0, 0);
                this.sceneManager.loadRegionAndMeshAllChunks(1, 0, 0);

                this.engine.runRenderLoop(() => {
                    this.scene.render();
                });

                window.addEventListener("resize", () => {
                    this.engine.resize();
                });
            }
        }
        
        const game = new Game("renderCanvas");
        game.start();
    </script>
</body>
</html>