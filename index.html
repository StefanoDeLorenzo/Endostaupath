<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Voxel Engine con Babylon.js</title>
    <style>
        body, html, canvas {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    
    <script>
        const CHUNK_SIZE = 30;
        const CHUNK_SIZE_SHELL = 32;
        const REGION_DIMENSION = 4;
        const RENDER_DISTANCE = 1;

        class SceneManager {
            constructor(scene, engine, canvas) {
                this.scene = scene;
                this.engine = engine;
                this.canvas = canvas;
                this.workers = new Map();
                this.sceneMaterials = {};
                this.loadedRegions = new Set();
                this.initializeScene();
            }

            initializeScene() {
                this.scene.ambientColor = new BABYLON.Color3(0.4, 0.4, 0.4);
                this.createCamera();
                this.createLight();
            }

            createCamera() {
                const camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(60, 60, 60), this.scene);
                camera.setTarget(new BABYLON.Vector3(60, 0, 60)); 
                camera.attachControl(this.canvas, true);
                camera.keysUp.push(87);    // W
                camera.keysDown.push(83);  // S
                camera.keysLeft.push(65);  // A
                camera.keysRight.push(68); // D
            }
            
            createLight() {
                const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), this.scene);
                light.intensity = 0.7;
            }

            getOrCreateMaterial(voxelType, isTransparent, materialAlpha = 1.0) {
                if (!this.sceneMaterials[voxelType]) {
                    const material = new BABYLON.StandardMaterial(`material_${voxelType}`, this.scene);
                    material.useVertexColors = true;
                    if (isTransparent) {
                        material.alpha = materialAlpha;
                        material.hasAlpha = true;
                        material.alphaMode = BABYLON.Engine.ALPHA_COMBINE;
                        material.backFaceCulling = false;
                    }
                    this.sceneMaterials[voxelType] = material;
                }
                return this.sceneMaterials[voxelType];
            }

            getChunkDataFromRegionBuffer(buffer, chunkX, chunkY, chunkZ) {
                const dataView = new DataView(buffer);
                const headerSize = 11;
                const chunkIndex = chunkZ + REGION_DIMENSION * (chunkY + REGION_DIMENSION * chunkX);
                const offsetIndex = headerSize + chunkIndex * 5;
                const chunkFileOffset = (dataView.getUint8(offsetIndex) << 16) | (dataView.getUint8(offsetIndex + 1) << 8) | dataView.getUint8(offsetIndex + 2);

                if (chunkFileOffset === 0) {
                    return null;
                }
                const chunkSizeInBytes = CHUNK_SIZE_SHELL * CHUNK_SIZE_SHELL * CHUNK_SIZE_SHELL;
                const chunkBuffer = buffer.slice(chunkFileOffset, chunkFileOffset + chunkSizeInBytes);
                return new Uint8Array(chunkBuffer);
            }

            async loadRegionDataAsync(regionX, regionY, regionZ) {
                const regionPath = `./regions/r.${regionX}.${regionY}.${regionZ}.voxl`;
                try {
                    const response = await fetch(regionPath);
                    if (!response.ok) {
                        console.log(`Regione (${regionX}, ${regionY}, ${regionZ}) non trovata. Trattata come vuota.`);
                        return null;
                    }
                    return await response.arrayBuffer();
                } catch (error) {
                    console.error(`Errore durante il caricamento del file della regione (${regionX}, ${regionY}, ${regionZ}):`, error);
                    return null;
                }
            }

            async loadRegionAndMeshAllChunks(regionX, regionY, regionZ) {
                const regionKey = `${regionX},${regionY},${regionZ}`;
                if (this.loadedRegions.has(regionKey)) {
                    return;
                }
                this.loadedRegions.add(regionKey);
                
                console.log(`Thread principale: Avvio caricamento regione (${regionX}, ${regionY}, ${regionZ})`);
                const buffer = await this.loadRegionDataAsync(regionX, regionY, regionZ);
                
                if (!buffer) {
                    this.loadedRegions.delete(regionKey);
                    return;
                }

                console.log(`Thread principale: File caricato. Dimensione: ${buffer.byteLength} byte.`);
                
                for (let chunkX = 0; chunkX < REGION_DIMENSION; chunkX++) {
                    for (let chunkY = 0; chunkY < REGION_DIMENSION; chunkY++) {
                        for (let chunkZ = 0; chunkZ < REGION_DIMENSION; chunkZ++) {
                            const chunkData = this.getChunkDataFromRegionBuffer(buffer, chunkX, chunkY, chunkZ);
                            if (chunkData === null) {
                                continue;
                            }
                            const workerId = `chunk_${regionX}_${regionY}_${regionZ}_${chunkX}_${chunkY}_${chunkZ}`;
                            const worker = new Worker('worker.js');
                            this.workers.set(workerId, worker);
                            
                            worker.onmessage = (event) => {
                                const { type, meshDataByVoxelType, voxelOpacity } = event.data;
                                if (type === 'meshGenerated' && meshDataByVoxelType) {
                                    const worldX = (regionX * REGION_DIMENSION + chunkX) * CHUNK_SIZE;
                                    const worldY = (regionY * REGION_DIMENSION + chunkY) * CHUNK_SIZE;
                                    const worldZ = (regionZ * REGION_DIMENSION + chunkZ) * CHUNK_SIZE;
                                    for (const voxelType in meshDataByVoxelType) {
                                        const meshData = meshDataByVoxelType[voxelType];
                                        if (meshData.positions.length > 0) {
                                            const isTransparent = (voxelOpacity[voxelType] === 'transparent');
                                            const meshName = `chunk_${regionX}_${regionY}_${regionZ}_${voxelType}`;
                                            const mesh = new BABYLON.Mesh(meshName, this.scene);
                                            const vertexData = new BABYLON.VertexData();
                                            Object.assign(vertexData, meshData);
                                            vertexData.applyToMesh(mesh);
                                            const materialAlpha = isTransparent ? meshData.colors[3] : 1.0;
                                            mesh.material = this.getOrCreateMaterial(voxelType, isTransparent, materialAlpha);
                                            mesh.position = new BABYLON.Vector3(worldX, worldY, worldZ);
                                        }
                                    }
                                    worker.terminate();
                                    this.workers.delete(workerId);
                                }
                            };
                            
                            // Corretto: ora passiamo solo i dati del chunk, non l'intero buffer della regione.
                            worker.postMessage({
                                type: 'generateMeshFromChunk',
                                chunkData: chunkData.buffer,
                                chunkX, chunkY, chunkZ
                            }, [chunkData.buffer]);
                        }
                    }
                }
            }

            unloadRegion(regionX, regionY, regionZ) {
                const regionKey = `${regionX},${regionY},${regionZ}`;
                if (!this.loadedRegions.has(regionKey)) {
                    return;
                }
                const meshes = this.scene.meshes.filter(mesh => mesh.name.startsWith(`chunk_${regionX}_${regionY}_${regionZ}`));
                meshes.forEach(mesh => {
                    mesh.dispose();
                });
                this.loadedRegions.delete(regionKey);
                console.log(`Regione (${regionX}, ${regionY}, ${regionZ}) scaricata.`);
            }

            updateRegions(playerPosition) {
                const currentRegionX = Math.floor(playerPosition.x / (CHUNK_SIZE * REGION_DIMENSION));
                const currentRegionY = Math.floor(playerPosition.y / (CHUNK_SIZE * REGION_DIMENSION));
                const currentRegionZ = Math.floor(playerPosition.z / (CHUNK_SIZE * REGION_DIMENSION));
                const regionsToLoad = new Set();
                for (let x = -RENDER_DISTANCE; x <= RENDER_DISTANCE; x++) {
                    for (let y = -RENDER_DISTANCE; y <= RENDER_DISTANCE; y++) {
                        for (let z = -RENDER_DISTANCE; z <= RENDER_DISTANCE; z++) {
                            const regionX = currentRegionX + x;
                            const regionY = currentRegionY + y;
                            const regionZ = currentRegionZ + z;
                            const regionKey = `${regionX},${regionY},${regionZ}`;
                            regionsToLoad.add(regionKey);
                            this.loadRegionAndMeshAllChunks(regionX, regionY, regionZ);
                        }
                    }
                }
                const regionsToUnload = new Set(this.loadedRegions);
                for (const regionKey of regionsToUnload) {
                    if (!regionsToLoad.has(regionKey)) {
                        const [regionX, regionY, regionZ] = regionKey.split(',').map(Number);
                        this.unloadRegion(regionX, regionY, regionZ);
                    }
                }
            }
        }

        class Game {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.engine = new BABYLON.Engine(this.canvas, true);
                this.scene = new BABYLON.Scene(this.engine);
                this.sceneManager = new SceneManager(this.scene, this.engine, this.canvas);
                this.player = this.scene.activeCamera;
            }

            start() {
                this.engine.runRenderLoop(() => {
                    this.scene.render();
                });

                window.addEventListener("resize", () => {
                    this.engine.resize();
                });

                setInterval(() => {
                    this.sceneManager.updateRegions(this.player.position);
                }, 1000);
            }
        }
        
        const game = new Game("renderCanvas");
        game.start();
    </script>
</body>
</html>