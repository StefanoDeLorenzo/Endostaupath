<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Marching Cubes con Babylon.js</title>
    <style>
        body, html, canvas {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="merchingCubeTableData.js"></script>
    <script src="chunk.js"></script>
    <script src="marching_mesher.js"></script>
</head>
<body>
    <canvas id="renderCanvas"></canvas>

    <script>
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);
        const scene = new BABYLON.Scene(engine);

        // Funzione per creare la telecamera
        function createCamera(scene) {
            const camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(60, 60, 60), this.scene);
                camera.setTarget(new BABYLON.Vector3(7.5, 7.5, 7.5));
                camera.inertia = 0.9; //0.9 è il default
                camera.angularSensibility = 5000; // 5000 è il default
                camera.attachControl(this.canvas, true);
                camera.keysUp.push(87);    // W
                camera.keysDown.push(83);  // S
                camera.keysLeft.push(65);  // A
                camera.keysRight.push(68); // D
        }

        createCamera(scene);
        const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0), scene);

        // Istanza del tuo chunk, con la dimensione aggiornata a 15.
        const myChunk = new Chunk(0, 0, 0);

        // Imposta un cubo di 5x5x5 al centro del chunk.
        const cubeSize = 5;
        const offset = 5;

        // Popoliamo i vertici con i dati di intensità.
        for (let x = 0; x < myChunk.size + 1; x++) {
            for (let y = 0; y < myChunk.size + 1; y++) {
                for (let z = 0; z < myChunk.size + 1; z++) {
                    if (x >= offset && x < offset + cubeSize && 
                        y >= offset && y < offset + cubeSize && 
                        z >= offset && z < offset + cubeSize) {
                        myChunk.setVertexIntensity(x, y, z, 7); // 7 = alta intensità (solido).
                    } else {
                        myChunk.setVertexIntensity(x, y, z, 0); // 0 = bassa intensità (vuoto).
                    }
                }
            }
        }

        // Popoliamo i voxel con i dati del tipo di blocco.
        for (let x = 0; x < myChunk.size; x++) {
            for (let y = 0; y < myChunk.size; y++) {
                for (let z = 0; z < myChunk.size; z++) {
                    if (x >= offset && x < offset + cubeSize - 1 && 
                        y >= offset && y < offset + cubeSize - 1 && 
                        z >= offset && z < offset + cubeSize - 1) {
                        myChunk.setVoxelType(x, y, z, 1); // 1 = tipo di blocco 'roccia'.
                    } else {
                        myChunk.setVoxelType(x, y, z, 0); // 0 = tipo di blocco 'aria'.
                    }
                }
            }
        }
        
        let vertexArray = myChunk.getVoxelVerticesData(1,1,1);

// La parte inferiore del cubo è "solida" (intensità > 4)
myChunk.setVertexIntensity(1, 1, 1, 7);  // Vertice posteriore sinistro
myChunk.setVertexIntensity(2, 1, 1, 7);  // Vertice posteriore destro
myChunk.setVertexIntensity(2, 1, 2, 7);  // Vertice anteriore destro
myChunk.setVertexIntensity(1, 1, 2, 7);  // Vertice anteriore sinistro

// La parte superiore del cubo è inclinata.
// L'altezza è rappresentata dall'intensità.
// I vertici sul lato destro (x=2) hanno un'intensità più alta, creando un'inclinazione.
myChunk.setVertexIntensity(1, 2, 1, 1);  // Vertice posteriore sinistro superiore (più basso)
myChunk.setVertexIntensity(2, 2, 1, 7);  // Vertice posteriore destro superiore (più alto)
myChunk.setVertexIntensity(2, 2, 2, 7);  // Vertice anteriore destro superiore (più alto)
myChunk.setVertexIntensity(1, 2, 2, 1);  // Vertice anteriore sinistro superiore (più basso)

         // 7 = alta intensità (solido).
        myChunk.setVoxelType(1, 1, 1, 1); // 1 = tipo di blocco 'roccia'.
       //myChunk.setVoxelType(0, 0, 0, 1)

        //const myChunkMesh = generateMesh(myChunk, scene);
        const myChunkMesh = generateHybridMesh(myChunk, scene);

        // Applica un materiale alla mesh per renderla visibile.
        const material = new BABYLON.StandardMaterial("material", scene);
        material.diffuseColor = new BABYLON.Color3(0.5, 0.5, 1);
        myChunkMesh.material = material;


        engine.runRenderLoop(() => {
            scene.render();
        });

        window.addEventListener("resize", () => {
            engine.resize();
        });
    </script>
</body>
</html>