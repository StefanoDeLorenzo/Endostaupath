<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Voxel Engine con Babylon.js</title>
    <style>
        body, html, canvas {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    
    <script>
        const CHUNK_SIZE = 30;
        const CHUNK_SIZE_SHELL = 32;
        const REGION_DIMENSION = 4;

        class SceneManager {
            constructor(scene, engine, canvas) {
                this.scene = scene;
                this.engine = engine;
                this.canvas = canvas;
                this.workers = new Map();
                this.sceneMaterials = {};
                this.loadedChunks = new Set();
                this.loadedRegions = new Set();
                this.regionsData = new Map();

                //this.engine.setHardwareScalingLevel(0.6667); // Imposta il livello di scaling hardware a 0.6667 per migliorare le prestazioni

                // Abilita le collisioni a livello di scena
                this.scene.collisionsEnabled = true;

                this.initializeScene();
            }

            initializeScene() {
                this.scene.ambientColor = new BABYLON.Color3(0.4, 0.4, 0.4);
                this.createCamera();
                this.createAmbientLight();
            this.shadowGenerator = this.createSunLight(); // Salva l'istanza del generatore di ombre
            }

            createCamera() {
                const camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(60, 60, 60), this.scene);
                camera.setTarget(new BABYLON.Vector3(60, 0, 60));
                camera.inertia = 0.5; //0.9 è il default
                camera.angularSensibility = 1500; // 5000 è il default
                camera.speed = 8; // Valore di default: 1

                camera.minZ = 0.05; // Valore di default: 0.1, frustum di vista, piano di taglio vicino, più piccolo è più vicino puoi vedere gli oggetti

                camera.attachControl(this.canvas, true);
                camera.keysUp.push(87);    // W
                camera.keysDown.push(83);  // S
                camera.keysLeft.push(65);  // A
                camera.keysRight.push(68); // D

                // Collisioni
                camera.checkCollisions = true;
                camera.ellipsoid = new BABYLON.Vector3(0.6, 0.875, 0.6); // Guscio di collisione della telecamera
                camera.ellipsoid.y = 2.9375; // Altezza della telecamera
            }
            
            createAmbientLight() {
                const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), this.scene);
                light.intensity = 0.3; // L'intensità va bene
                light.diffuse = new BABYLON.Color3(0.8, 0.8, 0.8); // Luce non troppo brillante
                light.groundColor = new BABYLON.Color3(0.5, 0.5, 0.5); // ✨ Aggiungi un colore per schiarire le ombre ✨
            }
            
            createSunLight() {
                //const sun = new BABYLON.PointLight("sun", new BABYLON.Vector3(60, 250, 60), this.scene);
                const sun = new BABYLON.DirectionalLight("sun", new BABYLON.Vector3(-0.5, -1, 0.25), this.scene);
                sun.intensity = 0.7;

                // La posizione serve solo per il ShadowGenerator, non per l'illuminazione
                sun.position = new BABYLON.Vector3(0, 150, 0);

                sun.shadowMinZ = 70;
                sun.shadowMaxZ = 200;
                
                const shadowGenerator = new BABYLON.ShadowGenerator(2048, sun);
                shadowGenerator.usePercentageCloserFiltering = true;
                shadowGenerator.usePoissonSampling = true;
                shadowGenerator.bias = 0.005;
                shadowGenerator.normalBias = 0.005;
                shadowGenerator.blurKernel = 128;

                return shadowGenerator;
            }

            getOrCreateMaterial(voxelType, isTransparent, materialAlpha = 1.0) {
                console.log("Creazione materiale per il voxelType:", voxelType, "Tipo:", typeof voxelType);
                if (!this.sceneMaterials[voxelType]) {
                    const material = new BABYLON.StandardMaterial(`material_${voxelType}`, this.scene);

                    
                    // Se il voxel è l'erba, applichiamo una bump map
                    if (Number(voxelType) === 3) {
                        console.log("Creazione bumpmapping per il materiale di Erba");
                        

                        material.useVertexColors = true;
                        // Per il bump mapping, usiamo la proprietà 'bumpTexture' del StandardMaterial
                        // Applica una texture di base. L'immagine di esempio è verde, che si adatta all'erba.
                        
                        //material.diffuseTexture = new BABYLON.Texture("./texture/t_grass.png", this.scene);

                        //material.emissiveColor = new BABYLON.Color3(1, 0, 0);
                        //material.specularColor = new BABYLON.Color3(1, 0, 0);
                        
                        // Puoi scalare la texture se necessario, proprio come con la bump map
                        //material.diffuseTexture.uScale = 1.0;
                        //material.diffuseTexture.vScale = 1.0;

                        material.bumpTexture = new BABYLON.Texture("./texture/m_grass.png", this.scene);
                        material.bumpTexture.level = 0.5;
                        material.bumpTexture.uScale = 2.0;
                        material.bumpTexture.vScale = 2.0;
                        
                        // Abilita il bump mapping
                        material.useParallax = true;
                        
                        // Nota: Le proprietà detailTexture, detailMap.bumpLevel ecc... 
                        // non sono disponibili per lo StandardMaterial.
                        // Le ho rimosse per evitare errori e confusione.
                    }else{
                        // Imposta i colori dei vertici per tutti i materiali come da progetto originale
                        material.useVertexColors = true;

                    }

                    if (isTransparent) {
                        material.alpha = materialAlpha;
                        material.hasAlpha = true;
                        material.alphaMode = BABYLON.Engine.ALPHA_COMBINE;
                        material.backFaceCulling = false;
                    }

                    //material.backFaceCulling = false; Non serve per le facce non trasparenti
                    this.sceneMaterials[voxelType] = material;
                }
                return this.sceneMaterials[voxelType];
            }
            
            getChunkDataFromRegionBuffer(buffer, chunkX, chunkY, chunkZ) {
                const dataView = new DataView(buffer);
                const headerSize = 11;
                const chunkIndex = chunkZ + REGION_DIMENSION * (chunkY + REGION_DIMENSION * chunkX);
                const offsetIndex = headerSize + chunkIndex * 5;
                const chunkFileOffset = (dataView.getUint8(offsetIndex) << 16) | (dataView.getUint8(offsetIndex + 1) << 8) | dataView.getUint8(offsetIndex + 2);

                if (chunkFileOffset === 0) {
                    return null;
                }
                const chunkSizeInBytes = CHUNK_SIZE_SHELL * CHUNK_SIZE_SHELL * CHUNK_SIZE_SHELL;
                const chunkBuffer = buffer.slice(chunkFileOffset, chunkFileOffset + chunkSizeInBytes);
                return new Uint8Array(chunkBuffer);
            }
            
            getChunkDataFromMemory(regionX, regionY, regionZ, chunkX, chunkY, chunkZ) {
                const regionKey = `${regionX}_${regionY}_${regionZ}`;
                if (!this.regionsData.has(regionKey)) {
                    return null;
                }
                const regionBuffer = this.regionsData.get(regionKey);
                return this.getChunkDataFromRegionBuffer(regionBuffer, chunkX, chunkY, chunkZ);
            }

            async fetchAndStoreRegionData(regionX, regionY, regionZ) {
                const regionKey = `${regionX}_${regionY}_${regionZ}`;
                if (this.loadedRegions.has(regionKey)) {
                    return;
                }
                
                try {
                    const regionPath = `./regions/r.${regionX}.${regionY}.${regionZ}.voxl`;
                    console.log(`Thread principale: Caricamento del file ${regionPath}...`);
                    const response = await fetch(regionPath);
                    if (!response.ok) {
                        console.error(`Regione (${regionX}, ${regionY}, ${regionZ}) non trovata. Trattata come vuota.`);
                        this.loadedRegions.add(regionKey);
                        return;
                    }
                    const buffer = await response.arrayBuffer();
                    console.log(`Thread principale: File caricato. Dimensione: ${buffer.byteLength} byte.`);
                    this.loadedRegions.add(regionKey);
                    this.regionsData.set(regionKey, buffer);
                } catch (error) {
                    console.error(`Errore durante il caricamento del file della regione (${regionX}, ${regionY}, ${regionZ}):`, error);
                }
            }
            
            // Versione adattata per worker_structured.js (ES module)
            async loadChunk(regionX, regionY, regionZ, chunkX, chunkY, chunkZ) {
            const chunkKey = `${regionX}_${regionY}_${regionZ}_${chunkX}_${chunkY}_${chunkZ}`;
            if (this.loadedChunks.has(chunkKey)) return;

            await this.fetchAndStoreRegionData(regionX, regionY, regionZ);

            const chunkData = this.getChunkDataFromMemory(regionX, regionY, regionZ, chunkX, chunkY, chunkZ);
            if (chunkData === null) {
                this.loadedChunks.add(chunkKey);
                return;
            }

            // Copia difensiva: evitiamo di trasferire il buffer dell'intera regione
            const vox = (chunkData instanceof Uint8Array) ? chunkData.slice() : new Uint8Array(chunkData);

            const workerId = `chunk_${regionX}_${regionY}_${regionZ}_${chunkX}_${chunkY}_${chunkZ}`;
            const worker = new Worker('./src/worker/worker_structured.js', { type: 'module' });
            this.workers.set(workerId, worker);

            // Calcolo world position come prima
            const worldX = (regionX * REGION_DIMENSION + chunkX) * CHUNK_SIZE;
            const worldY = (regionY * REGION_DIMENSION + chunkY) * CHUNK_SIZE;
            const worldZ = (regionZ * REGION_DIMENSION + chunkZ) * CHUNK_SIZE;

            // Handler messaggi
            worker.onmessage = (event) => {
                const msg = event.data;

                if (msg?.type === 'INIT_OK') {
                // Dopo l'ACK, invia il chunk (TRANSFER della copia)
                worker.postMessage({
                    type: 'BUILD_CHUNK',
                    key: { rx: regionX, ry: regionY, rz: regionZ, cx: chunkX, cy: chunkY, cz: chunkZ },
                    voxels: vox
                }, [vox.buffer]);
                return;
                }

                // Fine lavoro: crea la mesh unica per il chunk
                if (msg?.type === 'MESH_READY') {
                const { positions, normals, uvs, indices /*, counts, key */ } = msg;

                this.loadedChunks.add(chunkKey);

                if (positions && positions.length) {
                    const meshName = `chunk_${regionX}_${regionY}_${regionZ}_${chunkX}_${chunkY}_${chunkZ}`;
                    const mesh = new BABYLON.Mesh(meshName, this.scene);
                    const vertexData = new BABYLON.VertexData();

                    vertexData.positions = positions;
                    vertexData.indices   = indices;
                    vertexData.normals   = normals;
                    vertexData.uvs       = uvs;
                    // Niente colors dal worker strutturato (se servono li calcoliamo dopo)
                    vertexData.applyToMesh(mesh);

                    mesh.checkCollisions = true;
                    // Materiale “opaco” di default (Dirt=1). In seguito possiamo differenziare.
                    mesh.material = this.getOrCreateMaterial(1, false, 1.0);

                    mesh.position = new BABYLON.Vector3(worldX, worldY, worldZ);

                    // Ombre opzionali come nel tuo codice
                    this.shadowGenerator.addShadowCaster(mesh);
                    mesh.receiveShadows = true;
                }

                worker.terminate();
                this.workers.delete(workerId);
                return;
                }

                if (msg?.type === 'MESH_ERROR') {
                console.error('[worker] MESH_ERROR', msg.key, msg.error);
                this.loadedChunks.add(chunkKey);
                worker.terminate();
                this.workers.delete(workerId);
                return;
                }
            };

            // Inizializza il worker (una volta per worker)
            worker.postMessage({
                type: 'INIT',
                sizes: { shellSize: 32, logicalSize: 30, shellMargin: 1 }, // 32^3 con shell → 30^3 logico
                classify: { opaque: [1, 3, 4] }, // Dirt, Grass, Rock opachi
                uv: { atlasCols: 1 }             // niente atlas complesso per ora
            });
            }

            
            // Metodo per il caricamento iniziale di un'intera regione
            async loadRegionAndMeshAllChunks(regionX, regionY, regionZ) {
                await this.fetchAndStoreRegionData(regionX, regionY, regionZ);
                
                for (let chunkX = 0; chunkX < REGION_DIMENSION; chunkX++) {
                    for (let chunkY = 0; chunkY < REGION_DIMENSION; chunkY++) {
                        for (let chunkZ = 0; chunkZ < REGION_DIMENSION; chunkZ++) {
                            await this.loadChunk(regionX, regionY, regionZ, chunkX, chunkY, chunkZ);
                        }
                    }
                }
            }

            findChunksToLoad(playerPosition) {
                const currentRegionX = Math.floor(playerPosition.x / (CHUNK_SIZE * REGION_DIMENSION));
                const currentRegionY = Math.floor(playerPosition.y / (CHUNK_SIZE * REGION_DIMENSION));
                const currentRegionZ = Math.floor(playerPosition.z / (CHUNK_SIZE * REGION_DIMENSION));

                const currentChunkX = Math.floor((playerPosition.x - currentRegionX * CHUNK_SIZE * REGION_DIMENSION) / CHUNK_SIZE);
                const currentChunkY = Math.floor((playerPosition.y - currentRegionY * CHUNK_SIZE * REGION_DIMENSION) / CHUNK_SIZE);
                const currentChunkZ = Math.floor((playerPosition.z - currentRegionZ * CHUNK_SIZE * REGION_DIMENSION) / CHUNK_SIZE);
                
                const chunksToLoad = [];
                
                for (let x = -1; x <= 1; x++) {
                    for (let y = -1; y <= 1; y++) {
                        for (let z = -1; z <= 1; z++) {
                            const worldChunkX = currentChunkX + x;
                            const worldChunkY = currentChunkY + y;
                            const worldChunkZ = currentChunkZ + z;
                            
                            const adjacentRegionX = currentRegionX + Math.floor(worldChunkX / REGION_DIMENSION);
                            const adjacentRegionY = currentRegionY + Math.floor(worldChunkY / REGION_DIMENSION);
                            const adjacentRegionZ = currentRegionZ + Math.floor(worldChunkZ / REGION_DIMENSION);

                            const adjacentChunkX = (worldChunkX % REGION_DIMENSION + REGION_DIMENSION) % REGION_DIMENSION;
                            const adjacentChunkY = (worldChunkY % REGION_DIMENSION + REGION_DIMENSION) % REGION_DIMENSION;
                            const adjacentChunkZ = (worldChunkZ % REGION_DIMENSION + REGION_DIMENSION) % REGION_DIMENSION;
                            
                            const adjacentChunkKey = `${adjacentRegionX}_${adjacentRegionY}_${adjacentRegionZ}_${adjacentChunkX}_${adjacentChunkY}_${adjacentChunkZ}`;
                            if (!this.loadedChunks.has(adjacentChunkKey)) {
                                chunksToLoad.push({
                                    regionX: adjacentRegionX,
                                    regionY: adjacentRegionY,
                                    regionZ: adjacentRegionZ,
                                    chunkX: adjacentChunkX,
                                    chunkY: adjacentChunkY,
                                    chunkZ: adjacentChunkZ
                                });
                            }
                        }
                    }
                }
                return chunksToLoad;
            }
            
            async loadMissingChunks(chunksToLoad) {
                const loadingPromises = [];
                for (const chunk of chunksToLoad) {
                    // Avvia la chiamata ma non aspetta la risposta
                    loadingPromises.push(this.loadChunk(chunk.regionX, chunk.regionY, chunk.regionZ, chunk.chunkX, chunk.chunkY, chunk.chunkZ));
                }
                await Promise.all(loadingPromises); // Aspetta che tutte le promesse siano risolte
            }
            
            printDebugInfo(playerPosition, chunksToLoad) {
                const currentRegionX = Math.floor(playerPosition.x / (CHUNK_SIZE * REGION_DIMENSION));
                const currentRegionY = Math.floor(playerPosition.y / (CHUNK_SIZE * REGION_DIMENSION));
                const currentRegionZ = Math.floor(playerPosition.z / (CHUNK_SIZE * REGION_DIMENSION));

                const currentChunkX = Math.floor((playerPosition.x - currentRegionX * CHUNK_SIZE * REGION_DIMENSION) / CHUNK_SIZE);
                const currentChunkY = Math.floor((playerPosition.y - currentRegionY * CHUNK_SIZE * REGION_DIMENSION) / CHUNK_SIZE);
                const currentChunkZ = Math.floor((playerPosition.z - currentRegionZ * CHUNK_SIZE * REGION_DIMENSION) / CHUNK_SIZE);

                console.log("-----------------------------------------");
                console.log(`Posizione Camera: X: ${playerPosition.x}, Y: ${playerPosition.y}, Z: ${playerPosition.z}`);
                const currentRegionKey = `${currentRegionX}_${currentRegionY}_${currentRegionZ}`;
                console.log(`Regione Attuale: (${currentRegionX}, ${currentRegionY}, ${currentRegionZ}) - Caricata: ${this.loadedRegions.has(currentRegionKey)}`);
                const currentChunkKey = `${currentRegionX}_${currentRegionY}_${currentRegionZ}_${currentChunkX}_${currentChunkY}_${currentChunkZ}`;
                console.log(`Chunk Attuale: (${currentChunkX}, ${currentChunkY}, ${currentChunkZ}) - Caricato: ${this.loadedChunks.has(currentChunkKey)}`);
                console.log("-----------------------------------------");
                console.log(`Trovati ${chunksToLoad.length} chunk da caricare nelle vicinanze.`);
                console.log("-----------------------------------------");
            }
        }

        class Game {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.engine = new BABYLON.Engine(this.canvas, true);
                this.scene = new BABYLON.Scene(this.engine);
                this.sceneManager = new SceneManager(this.scene, this.engine, this.canvas);
                this.player = this.scene.activeCamera;
                
                this.lastChunk = { x: null, y: null, z: null };
            }

            async start() {
                // Caricamento iniziale di due regioni all'avvio
                await this.sceneManager.loadRegionAndMeshAllChunks(0, 0, 0);
                await this.sceneManager.loadRegionAndMeshAllChunks(1, 0, 0);
                
                this.engine.runRenderLoop(() => {
                    this.scene.render();
                    this.checkCameraPosition();
                });

                window.addEventListener("resize", () => {
                    this.engine.resize();
                });
            }

            checkCameraPosition() {
                const playerPosition = this.player.position;
                const currentRegionX = Math.floor(playerPosition.x / (CHUNK_SIZE * REGION_DIMENSION));
                const currentRegionY = Math.floor(playerPosition.y / (CHUNK_SIZE * REGION_DIMENSION));
                const currentRegionZ = Math.floor(playerPosition.z / (CHUNK_SIZE * REGION_DIMENSION));

                const currentChunkX = Math.floor((playerPosition.x - currentRegionX * CHUNK_SIZE * REGION_DIMENSION) / CHUNK_SIZE);
                const currentChunkY = Math.floor((playerPosition.y - currentRegionY * CHUNK_SIZE * REGION_DIMENSION) / CHUNK_SIZE);
                const currentChunkZ = Math.floor((playerPosition.z - currentRegionZ * CHUNK_SIZE * REGION_DIMENSION) / CHUNK_SIZE);

                if (currentChunkX !== this.lastChunk.x || currentChunkY !== this.lastChunk.y || currentChunkZ !== this.lastChunk.z) {
                    const chunksToLoad = this.sceneManager.findChunksToLoad(playerPosition);
                    if (chunksToLoad.length > 0) {
                        this.sceneManager.loadMissingChunks(chunksToLoad);
                    }
                    this.sceneManager.printDebugInfo(playerPosition, chunksToLoad);
                    this.lastChunk = { x: currentChunkX, y: currentChunkY, z: currentChunkZ };
                }
            }
        }
        
        const game = new Game("renderCanvas");
        game.start();
    </script>
</body>
</html>